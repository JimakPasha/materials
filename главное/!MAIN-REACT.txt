-----------------------------------------------------------------------
-----------------------------------------------------------------------
JSX 
-----------------------------------------------------------------------
-----------------------------------------------------------------------
Что такое JSX?

Расширение JS. 
После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.

Babel компилирует JSX в вызовы React.createElement().

Из этого следует, что JSX можно использовать внутри выражений if и циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.

Поскольку JSX ближе к JavaScript чем к HTML, React DOM использует стиль именования camelCase для свойств вместо обычных имён HTML-атрибутов.

Например, class становится className в JSX, а tabindex становится tabIndex.
-----------------------------------------------------------------------
-----------------------------------------------------------------------
React DOM 
-----------------------------------------------------------------------
-----------------------------------------------------------------------
What is the virtual DOM? How does react use the virtual DOM to render the UI?

_!!!В отличие от DOM-элементов, элементы React — это простые объекты, не отнимающие много ресурсов. React DOM обновляет DOM, чтобы он соответствовал переданным React-элементам.

_!!!React обновляет только то, что необходимо
React DOM сравнивает элемент и его дочернее дерево с предыдущей версией и вносит в DOM только минимально необходимые изменения.

Преимущества и отличия VDOM от DOM
- Очень маленькое потребление памяти
- Обновляется быстрее
- Манипуляции с DOM очень просты
- Невозможно обновить HTML напрямую
- Если элемент обновлен, обновляется JSX

-----------------------------------------------------------------------
ЧТО ТАКОЕ ВИРТУАЛЬНЫЙ DOM?
!!!Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется СОГЛАСОВАНИЕМ.

Такой подход и делает API React декларативным: вы указываете, в каком состоянии должен находиться пользовательский интерфейс, а React добивается, чтобы DOM соответствовал этому состоянию. Это абстрагирует манипуляции с атрибутами, обработку событий и ручное обновление DOM, которые в противном случае пришлось бы использовать при разработке приложения.

Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React.
-----------------------------------------------------------------------
ЧТО ТАКОЕ DOM — способ представления структурного документа с помощью объектов. Главная проблема DOM — он никогда не был рассчитан для создания динамического UI. После небольшого скроллинга, мы будем иметь десятки тысяч DOM-узлов, эффективно взаимодействовать с которыми — задача не из легких. Virtual DOM
_!!!Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM.
_!!!При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено.

https://habr.com/ru/post/256965/


-----------------------------------------------------------------------

ТЕНЕВОЙ DOM ПОХОЖ НА ВИРТУАЛЬНЫ?

Нет, они совсем разные. Теневой DOM (Shadow DOM) — это браузерная технология, предназначенная в основном для определения области видимости переменных и CSS в веб-компонентах. Мы не можем получить доступ к теневому DOM встроенных элементов с помощью обычных JS-вызовов или с помощью селекторов. Это не просто обычные потомки, это мощное средство инкапсуляции. Виртуальный DOM — это концепция, реализованная библиотеками в JavaScript поверх API браузера.

-----------------------------------------------------------------------
-----------------------------------------------------------------------
Render
-----------------------------------------------------------------------
-----------------------------------------------------------------------

When is a component rendered?
How not to render on props change?
Is it OK to use arrow functions in render methods?

-----------------------------------------------------------------------
-----------------------------------------------------------------------
Interaction between components
-----------------------------------------------------------------------
-----------------------------------------------------------------------
How do you pass a value from parent to child?
How do you pass a value from child to parent?
How do you pass a value from sibling to sibling?

https://medium.com/@jmuse/%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8-%D0%B2-react-d86394da2b50

-----------------------------------------------------------------------
What is prop drilling?
это процесс в приложении React, при котором свойства передаются из одной части дерева в другую, проходя через другие части, которым не нужны данные, а только помогают в передаче их через дерево.
-----------------------------------------------------------------------
Can a child component modify its own props?

Компонент может обновлять свое собственное состояние, но не может обновлять свои собственные свойства.
React требует, чтобы вы относились к реквизитам как к доступным только для чтения (даже если есть способы с ними возиться)

Подумайте об этом так: свойства принадлежат родительскому компоненту, а не дочернему компоненту - дочерний компонент не имеет права изменять значение, которым он не владеет. 
Таким образом, реквизиты доступны только для чтения.

Попытка изменить props либо вызовет очевидные проблемы, либо, что еще хуже, переведет ваше приложение React в слегка нестабильное состояние.
React требует, чтобы обновить пользовательский интерфейс, обновить состояние.


-----------------------------------------------------------------------
-----------------------------------------------------------------------
Lifecycle and State
-----------------------------------------------------------------------
-----------------------------------------------------------------------
What is the difference between props and state?

Хотя каждый из них содержат информацию, которая влияет на результат отрисовки компонента, между ними имеется важное отличие: props передается компоненту (аналогично параметрам функции), тогда как state управляется внутри компонента (подобно переменным, объявленным внутри функции).
-----------------------------------------------------------------------
Чем состояние компонента класса отличается от состояния функционального компонента?

Состояние в компоненте класса принадлежит экземпляру класса (this) и инициализируется вместе с классом в функции конструктора.
В функциональном компоненте хук useState вызывается каждый раз, когда компонент отрисовывает и возвращает состояние, запомненное React под капотом.
-----------------------------------------------------------------------
What is the component lifecycle?

componentWillMount - компонент будет примонтирован. В данный момент у нас нет возможности посмотреть DOM элементы.

_!!!componentDidMount - запускается после того, как компонент отрендерился в DOM. компонент примонтировался. В данный момент у нас есть возможность использовать refs, а следовательно это то самое место, где мы хотели бы указать установку фокуса. Так же, таймауты, ajax-запросы и взаимодействие с другими библиотеками стоит обрабатывать здесь.

componentWillReceiveProps - компонент получает новые props. Этод метод не вызывается в момент первого render'a.

_!!!shouldComponentUpdate - должен ли компонент обновиться? На самом деле, обычно реакт сам отлично разбирается. Но иногда ручное управление позволяет существенно ускорить работу в "узких местах". С этим методом нужно работать очень аккуратно.

componentWillUpdate - вызывается прямо перед render, когда новые props и state получены. В этом методе нельзя вызывать setState.

_!!!componentDidUpdate - вызывается сразу после render. Не вызывается в момент первого render'а компонента.

_!!!componentWillUnmount - вызывается сразу перед тем, как компонент будет удален из DOM.

https://max-frontend.gitbook.io/react-course-ru/zhiznennii_tsikl_komponenta

---
Монтирование:

1) constructor()
- Конструкторы в React обычно используют для двух целей: 
Инициализация внутреннего состояния через присвоение объекта this.state.
Привязка обработчиков событий к экземпляру.
- Можете не использовать конструктор в React-компоненте, если вы не определяете состояние или не привязываете методы.
- Конструктор компонента React вызывается до того, как компонент будет примонтирован.
- В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. 
- Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState().

2) render()
- единственный обязательный метод в классовом компоненте.
- При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов:
Элемент React. - JSX
Массивы и фрагменты. - Возвращает несколько элементов из render().
Порталы. - Рендерит несколько дочерних элементов в другое поддерево DOM.
Строки и числа. - Рендерит текстовые DOM-узлы.
- Функция render() должна быть чистой. Это означает, что она не изменяет состояние компонента, всегда возвращает один и тот же результат, не взаимодействует напрямую с браузером.
- не вызывается, если shouldComponentUpdate() возвращает false.

3) componentDidMount()
- вызывается сразу после монтирования (то есть, вставки компонента в DOM).
- В этом методе должны происходить действия, которые требуют наличия DOM-узлов.
- Это хорошее место для создания сетевых запросов.
- Вы можете сразу вызвать setState(). Это вызовет дополнительный рендер перед тем, как браузер обновит экран.

Обновление:
1) componentDidUpdate()
- вызывается сразу после обновления. Не вызывается при первом рендере.
- Это хорошее место для создания сетевых запросов. как и в componentDidMount()
- можно вызывать setState(), однако его необходимо обернуть в условие, чтобы не возник бесконечный цикл.
- не вызывается, если shouldComponentUpdate() возвращает false.

Размонтирование:
1) componentWillUnmount()
- вызывается непосредственно перед размонтированием и удалением компонента из DOM
- В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().

Обработка ошибок:
1) componentDidCatch()
- Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает 2 параметра:
error — перехваченная ошибка
info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка.
- вызывается во время этапа «фиксации», поэтому здесь можно использовать побочные эффекты.
- Метод можно использовать для логирования ошибок.

Редко используемые:
1) shouldComponentUpdate()
- Используйте его, чтобы указать необходимость следующего рендера на основе изменений состояния и пропсов.
- вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true.
- Этот метод не вызывается при первом рендере или когда используется forceUpdate().
- Этот метод нужен только для повышения производительности. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.

-----------------------------------------------------------------------
-----------------------------------------------------------------------
useRef
-----------------------------------------------------------------------
-----------------------------------------------------------------------
What is the difference between refs and state variables?

!- И реф и стейт позволяют сохранить значения между отрисовками, однако только стейт запускает re-render.
- реф используется для прямого доступа к DOM элементам.
- нет особых причин использовать ref в компонентах класса, потому что более естественно хранить эти значения в полях, которые принадлежат экземпляру класса и будут сохраняться между рендерингами независимо.

-----------------------------------------------------------------------
When is the best time to use refs?
- Наиболее нужны только 2 способа
1) для доступа к DOM элементу (сторонняя библиотека DOM, запуск императивной анимации)
2) в функциональных компонентах, где они иногда являются хорошим выбором утилит для сохранения значений между рендерингами, не вызывая повторный рендеринг компонента при изменении значения

-----------------------------------------------------------------------
-----------------------------------------------------------------------
Context
-----------------------------------------------------------------------
-----------------------------------------------------------------------
What is the difference between the context API and prop drilling?

- drilling является явной и, следовательно, многословной, но, по крайней мере, вы знаете, что получите. Context API является неявным и поэтому кратким, но при неправильном использовании может вызвать ненужные повторные отрисовки.

-----------------------------------------------------------------------
-----------------------------------------------------------------------
useContext
-----------------------------------------------------------------------
-----------------------------------------------------------------------
Используется для того, чтобы не делать prop drilling, и минуя всех childrens которым не нужны данные, доставлять данные прямиком куда нужно. 


-----------------------------------------------------------------------
When shouldn't you use the context API?



- Основным недостатком Context API является то, что каждый раз при изменении контекста все компоненты, потребляющие значение, повторно отрисовываются. Это может иметь негативные последствия для производительности.

 По этой причине вы должны использовать Context только для нечасто обновляемых данных.

-----------------------------------------------------------------------
РАЗЛИЧИЯ ХУКОВ КОНТЕКСТА , РЕДЬЮСЕРА И РЕДАКСА

https://habr.com/ru/post/539346/

-----------------------------------------------------------------------
Portal и функция createPortal 

предоставляют способ рендеринга дочерних элементов в дополнительной точке монтирования (в дополнение к основной точке монтирования, переданной в ReactDOM.render).
-----------------------------------------------------------------------
USECALLBACK

Хук useCallback вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей. 

Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров

-----------------------------------------------------------------------
USEMEMO

Возвращает мемоизированное значение.

useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.
-----------------------------------------------------------------------
HOC

Функция, которая на входе в параметрах принимает компонент, а на выходе возвращает новый компонент - контейнерный компонент для переданного в параметрах компонента.

HOC - это не компонент

Иначе: HOC позволяет нам создавать однотипные контейнерные компоненты для разных целевых компонент. А задача контейнерной компоненты - дать целевой презентационной компоненте какие-то данные\поведение.

-----------------------------------------------------------------------

USEREDUCER

Он позволяет работать со стейтом, только через редьюсер
хук для создания редюсера который возвращает состояние и возможность диспатчить изменения:
const [state, dispatch] = useReducer(reducer, initialState);

Так же useReducer принимает 3 аргумент, это action который должен выполнятся при инициализации редюсера:
  const [state, dispatch] = useReducer(
    reducer,
    initialState,
    {type: 'reset', payload: initialCount},
  );
-----------------------------------------------------------------------
-----------------------------------------------------------------------
РЕДАКС
-----------------------------------------------------------------------
-----------------------------------------------------------------------

Redux позволяет управлять состоянием ваших веб-приложений, созданных на любом JavaScript фреймворке

Redux предоставляет один объект, который хранит состояние приложения в одном месте, который может включать данные из серверного API или внешнего API, состояния навигации, информацию о пользователе, переключенное состояние кнопки и т.д.

