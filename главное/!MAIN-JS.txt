регулярки
прототипы
структуры данных
ООП


-----------------------------------------------
CONST LET VAR

- var если объявляется в глобальной области видимости, то она там и доступна, если в локальной то только там
мы можем написать var a = 1; var a = 2; и он не скажет что такая перменная уже есть.

- let и const имеет блочную область видимости

-----------------------------------------------
ЧТО ТАКОЕ USE STRICT?

Позволяет использовать более строгий вариант js синтаксиса. Он заменяет исключениями некоторые ошибки, которые JS интерпретатор пропускает по умолчанию
В es6 он по умолчанию включен (при транспайлинге бэйбл добовляет)

В строгом режиме:
Нельзя присваивать значение в неопределённую переменную
this не преобразуется в объект, а если значение this - undefined или null, то не преобразуется в глобальный объект
больше слов, зарезервированных для использования в будущем
и ещё много...

-----------------------------------------------
&& и ||

- && (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежании лишних затрат.

- || (или) находит и возвращает первое истинное значение. Он также использует короткое замыкание.
Данный оператор использовался для присвоения параметров по умолчанию в функциях до того, как параметры по умолчанию были стандартизированы в ES6.

-----------------------------------------------
ОТЛИЧИЯ NULL И UNDEFINED

- отличия null и undefined
null - Это значение присваивания, которое используется с переменной для представления значения.
undefined - Это переменная, которой не присвоено никакого значения, поэтому JavaScript присвоит ей значение undefined (это тип данных).

-----------------------------------------------
ПРЕВЕДЕНИЕ ТИПОВ и ТИПЫ


typeof null // object, это неточность js, на самом делел null это null
typeof function(){} // function, но на самом деле это object
typeif NaN// number, так и есть

Если складываем пустой массив с

console.log(Boolean([], {}, function(){})) // true
console.log('' + 1 + 0); // строка 10
console.log('' - 1 + 0); // число -1
console.log('3' * '2'); // число  6
console.log('42' - 40); // число  2
console.log('42px' - 40); // число Nan
console.log(null + 2); // число 2 (null преобразуется к числу 0)
console.log(undefined + 2); // число Nan (undefined не преобразуется к числу)
console.log([] + 1 + 2); // строка 12. [] это пустая строка ''

console.log('0' == false); // true. т.к. интерпритатор приводит это всё к числу. 0 это 0, false это 0

// неодночзначные
console.log(false == ''); // t
console.log(false == []); // t
console.log(false == {}); // f
console.log('' == 0); // t
console.log('' == []); // t
console.log('' == {}); // f
console.log(0 == []); // t
console.log(0 == {}); // f
console.log(0 == null); // f

-----------------------------------------------
ПЕРЕМЕННАЯ

Это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

-----------------------------------------------
FUNCTION DECLARATION И FUNCTION EXPRESSION

Function Declaration - когда движок JS готовится выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и инициализирует их. В результате, функции, созданные, как Function Declaration могут быть вызваны раньше своих определений.

Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.

-----------------------------------------------
ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ (LexicalEnvironment)

У каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением.

Объект лексического окружения состоит из двух частей:
- Environment Record – объект, в котором как свойства ХРАНЯТСЯ все ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ (а также некоторая другая информация, такая как значение this).
- Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

-----------------------------------------------
HOISTING

Подъем переменной (которая объявлена с помощью var) или функции (декларейшн) в глобальную или функциональную области видимости. Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.

Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения.
Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение.

Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления.

-----------------------------------------------
ОБЛАСТЬ ВИДИМОСТИ (SCOPE)

Место откуда мы имеем доступ к переменным или функциям.
В JS три типа области видимости:
1. глобальные - переменные и функции объявленные в данной функции становятся глобальными, доступны из любого места в коде
2. функциональная или локальная - переменные и ф объявленные внутри ф, доступны только этой ф и другим вложеным функциям
3 блочная - область видимости внутри {}. с приходом es6, работает для let и const

-----------------------------------------------
CALLBACK FUNCTION

это функция (или обратный вызов), переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия.

-----------------------------------------------
LEXICAL ENVIRONMENT

1. Окружение (формируется во время интерпретации JS) это некий объект который содержит 2 свойства: 1) объект который содержит свои локальные переменные 2) ссылку на внешнее окружение (родителя).
При объявлении функции она содержит внутри себя в скрытом поле, которое мы не можем посмотреть (называется ENVIRONMENT), ссылку на окружение где она была создана. Когда она вызывается, то создаётя новое окружение, именно для этой функции.
2. Сигнал для JS, чтобы создать новое окружение, служат фигурные скобки {}
3. сначала js ищет переменные во внутр окруж, потом пытается найти на уровне выше, пока не встретит null

-----------------------------------------------
ЗАМЫКАНИЯ

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и все они могут получить доступ к внешним переменным. В JS все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").

https://learn.javascript.ru/closure#okruzhenie-v-detalyah

!!!2)
замыкание — это способность функции иметь доступ (обращаться) к своему внешнему лексическому окружению. Иными словами: это механизм с помощью которого функция может иметь доступ к переменным, которые были объявлены в "месте рождения" этой функции. То-есть, благодаря замыканию, функция не теряет связь с переменными, которые существуют\существовали в её внешнем лексическом окружении.

-----------------------------------------------
ПЕРЕДАЧА ПО ССЫЛКЕ И ПО ЗНАЧЕНИЮ
КАК КОПИРОВАТЬ МАССИВЫ И ОБЪЕКТЫ 

В отличии от примитвов объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) на это значение. Поэтому копирование такой переменной или передача её в качестве аргумента функции приводит к копированию этой ссылки, а не самого объекта.

- Объекты 
1) создать пустой объект, и методом перебора перебрать все ключи старого объекта и положить в новый и вернуть новый объект !!! самый надёжный. глубоко можно скопировать как можем
2) Object.assign(numbers, add)); // первым аргументом пишем к которому будем присоединять. можно первый аргументом просто пустой объект
3) spread оператор
4) JSON.stringify JSON.parse

Однако это всё поверхностные копирования объектов, глубокие копии делать сдлжнее

-массивы
1) slice
2)spread оператор

-----------------------------------------------
DOM

DOM - представляет собой всё содержимое html страницы в виде объектов, кот. ты можешь менять
- getElementById , getElementsByTagName, getElementsByClassName, querySelectorAll, querySelector
- чтобы посмотреть что мы можем сделать с тем или иным элементом на странице. можем посмотреть на него в качестве объекта console.dir(box);
- style.border, style.cssText
- createElement, createTextNode 
- div.classList.add('black');
- document.body.append(div); prepend, before, remove, replaceWith
- childNodes получает коллекцию нод узлов
- createElement создаёт элемент
- чтобы вставить мы можем использовать before, after, prepend, append

-----------------------------------------------
EVENT LOOP

Задача event loop - наблюдать за стеком и за очередью задач, и если стек пуст, то из очереди докидывать в stack
JS - однопоточный язык. Тут вопрос, как в однопоточном js выполнять асинхронный код, для этого нам нужен eventLoop (концепция цикла событий)

EL переносит наши задачи в стек вызовов(callstack)
WEB API - предоставляет слушатели событий и сетТаймаут
Очеред задач (Callback queue). задачи из очереди ждут опустошения стека

-----------------------------------------------
ЧИСТАЯ ФУНКЦИЯ

Принципы:
1) Иммутабельность
Данные, которые в неё приходят не должны изменяться. 
(например в реакте jsx возвращаемый, не может менять пропсы, т.к. ссылочный тип данных или редьюсер чистая ф)

2) она должна что-то return

3) нет сайд эффектов (не использовал глобальные переменные, то что пришло, нет асинхронных запросов)

4) детерминированность(предсказуемость) или идемпотентность - это значит какие бы данные на вход не приходили, вернёт один и тот же ответ

-----------------------------------------------
РЕКУРСИЯ

Функция вызывает сама себя

Итак, рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его – к ещё более простому и так далее, пока значение не станет очевидно.

- Шагом рекурсии функция вызывает саму себя, это называется. 
- База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.

Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии. (100 000)

https://learn.javascript.ru/recursion

-----------------------------------------------
PROMISES

Промисы — это один из приемов работы с асинхронным кодом в JS. Они возвращают результат асинхронной операции. Промисы были придуманы для решения проблемы callback hell
Промис (promise) - это объект, представляющий результат успешного или неудачного завершения асинхронной операции. Асинхронная операция, упрощенно говоря, это некоторое действие, выполняется независимо от окружающего ее кода, в котором она вызывается, не блокирует выполнение вызываемого кода.

- У промиса есть три состояния: pending fulfilled rejected
- В качестве параметров конструктор промиса принимает resolve и reject
- Результат может быть обработан в методе .then, ошибка — в методе .catch. Метод .then также возвращает промис, поэтому мы можем использовать цепочку, состоящую из нескольких .then.

- Promise.all() - возвращает единый объект Promise, который объединяет набор промисов. Значения всех промисов возвращаются только если все они завершились успешно. Если хотя бы один reject, то пойдёт в catch
Promise.all([принимает набор промисов, промис1, промис2])then...
- Promise.allSettled - принимает набор промисов и выполняет их как единое целое, но возвращает объект со статусом и результатом промиса.
- Promise.race() также принимает несколько промисов, только возвращает первый завершенный промис (вне зависимости завершился от успешно или с ошибкой)
- Promise.any() принимает несколько промисов и возвращает первый успешно завершившийся промис. Если же все промисы завершились с ошибкой, то генерируется исключение типа AggregateError. С помощью свойства errors типа AggregateError можно получить в виде массива все ошибки, которые возникли в промисах.

-----------------------------------------------
ASYNC/AWAIT

Cпособ написания асинхронного кода в JS. Им оборачивают промис. Он делает код более читаемым и чистым, чем промисы и функции обратного вызова.

- «async» ставим перед функцией и заставляет ее возвращать промис
- «await» можно использовать только внутри асинхронной функции. Ожидает завершения выражения справа, чтобы вернуть его значение перед выполнением следующей строчки кода.

-----------------------------------------------
THIS

This это контекст вызова, то что окружает функцию и в каких условиях она вызывается.
This - это привязка, которая создаётся во время вызова функции, и на что она ссылается определяется тем, где и при каких условиях функция была вызвана.

- Обычная функция: this = window, но если use strict - undefined
- Контекст у методов объектов - это сам объект
- this в конструкторах и классах - это новый экземпляр объекта
- Ручная привязка this с помощью методов call, apply, bind

-----------------------------------------------

CLASSES

Классы — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование

-----------------------------------------------

NEW

Используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).

«new» делает 4 вещи:

- Создает пустой объект.
- Привязывает к нему значение this.
- Функция наследует от functionName.prototype.
- Возвращает значение this, если не указано иное.

-----------------------------------------------

...REST

const log = function(a, b, ...rest) { // допустим, у нас есть два обязательных аргумента, а дальше мы не знаем будут ли они, и сколько их будет, если вообще будут. Для этого топератор ....rest. Он всегда записывается в конце. при этом сам оператор это три точки, а название после может быть любым
	console.log(a, b, rest);
}

log('basic', 'rest', 'operator', 'usage'); 
// basic rest [ 'operator', 'usage' ] мы получим обязательные аргументы просто, а остальные в массиве. Т.е. rest собирает в массив.


-----------------------------------------------

FETCH

let promise = fetch(url, [options])
url – URL для отправки запроса.
options – дополнительные параметры: метод, заголовки и так далее.

- Без options это простой GET-запрос, скачивающий содержимое по адресу url.

1) Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер пришлёт заголовки ответа.
на этом этапе Мы можем увидеть HTTP-статус в свойствах ответа:
status: код
ok: если код 200, то true

2) Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.

Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:

response.text() – читает ответ и возвращает как обычный текст,
response.json() – декодирует ответ в формате JSON,
response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),
response.blob() – возвращает объект как Blob (бинарные данные с типом),
response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),
помимо этого, response.body – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. Мы рассмотрим и такой пример несколько позже.

-----------------------------------------------

HTTP

HyperText Transfer Protocol Протокол.
Задача - обмен данными между пользовательским приложением, осуществляющим доступ к веб-ресурсам (обычно это веб-браузер) и веб-сервером. 

Методы:
GET, POST, PUT, PATCH, DELETE, CONNECT

Коды состояния: 100 инфо, 200 ок, 300 редирект, 400 ерор клиент, 500 ерор сервер

Заголовки и тело сообщения ещё есть.

-----------------------------------------------


доп инфа
https://habr.com/ru/post/486820/
открыть вс код с теорией и чистым js
блокноты 2
ещё теорию вёрстки




__________________________________________________________________________________________________________________________________________________________________________________________________________________
2 && 1 && null && 0 && undefined // ответ null. Разберём почему. Дело в том что && всегда зпинается на false, и выводит значение того, кто дал этот false. И т.к. 2 и 1 это true, a null это false, он запнулся на null и вывел нам его.

null || 2 && 3 || 4 // ответ 3. Сначала мы должны понять какой логичекий оператор слеудет выполнять первее, поэтому мы гуглим приорететы операторов js. выясняем, что у && приоретет выше и мы его выполняем первым. 2 && 3 даёт нам true и в 2 и в 3, и т.к. последний 3, то тут будет 3. Далее выполняем null || 3 , и тут следует знать, что || запинается на правде(true) а дальше не идёт, поэтому ответ 3.