-----------------------------------------------
CONST LET VAR

- var если объявляется в глобальной области видимости, то она там и доступна, если в локальной то только там
мы можем написать var a = 1; var a = 2; и он не скажет что такая перменная уже есть.

- let и const имеет блочную область видимости

-----------------------------------------------
ЧТО ТАКОЕ USE STRICT?

Позволяет использовать более строгий вариант js синтаксиса. Он заменяет исключениями некоторые ошибки, которые JS интерпретатор пропускает по умолчанию
В es6 он по умолчанию включен (при транспайлинге бэйбл добовляет)

В строгом режиме:
Нельзя присваивать значение в неопределённую переменную
this не преобразуется в объект, а если значение this - undefined или null, то не преобразуется в глобальный объект
больше слов, зарезервированных для использования в будущем
и ещё много...

-----------------------------------------------
&& и ||

- && (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежании лишних затрат.

- || (или) находит и возвращает первое истинное значение. Он также использует короткое замыкание.
Данный оператор использовался для присвоения параметров по умолчанию в функциях до того, как параметры по умолчанию были стандартизированы в ES6.

-----------------------------------------------
ОТЛИЧИЯ NULL И UNDEFINED

- отличия null и undefined
null - Это значение присваивания, которое используется с переменной для представления значения.
undefined - Это переменная, которой не присвоено никакого значения, поэтому JavaScript присвоит ей значение undefined (это тип данных).

-----------------------------------------------
ПРЕВЕДЕНИЕ ТИПОВ и ТИПЫ


typeof null // object, это неточность js, на самом делел null это null
typeof function(){} // function, но на самом деле это object
typeif NaN// number, так и есть

Если складываем пустой массив с

console.log(Boolean([], {}, function(){})) // true
console.log('' + 1 + 0); // строка 10
console.log('' - 1 + 0); // число -1
console.log('3' * '2'); // число  6
console.log('42' - 40); // число  2
console.log('42px' - 40); // число Nan
console.log(null + 2); // число 2 (null преобразуется к числу 0)
console.log(undefined + 2); // число Nan (undefined не преобразуется к числу)
console.log([] + 1 + 2); // строка 12. [] это пустая строка ''

console.log('0' == false); // true. т.к. интерпритатор приводит это всё к числу. 0 это 0, false это 0

// неодночзначные
console.log(false == ''); // t
console.log(false == []); // t
console.log(false == {}); // f
console.log('' == 0); // t
console.log('' == []); // t
console.log('' == {}); // f
console.log(0 == []); // t
console.log(0 == {}); // f
console.log(0 == null); // f

-----------------------------------------------
ПЕРЕМЕННАЯ

Это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

-----------------------------------------------
FUNCTION DECLARATION И FUNCTION EXPRESSION

Function Declaration - когда движок JS готовится выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и инициализирует их. В результате, функции, созданные, как Function Declaration могут быть вызваны раньше своих определений.

Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.

-----------------------------------------------
ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ (LexicalEnvironment)

У каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением.

Объект лексического окружения состоит из двух частей:
- Environment Record – объект, в котором как свойства ХРАНЯТСЯ все ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ (а также некоторая другая информация, такая как значение this).
- Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

-----------------------------------------------
HOISTING

Подъем переменной (которая объявлена с помощью var) или функции (декларейшн) в глобальную или функциональную области видимости. Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.

Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения.
Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение.

Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления.

-----------------------------------------------
ОБЛАСТЬ ВИДИМОСТИ (SCOPE)

Место откуда мы имеем доступ к переменным или функциям.
В JS три типа области видимости:
1. глобальные - переменные и функции объявленные в данной функции становятся глобальными, доступны из любого места в коде
2. функциональная или локальная - переменные и ф объявленные внутри ф, доступны только этой ф и другим вложеным функциям
3 блочная - область видимости внутри {}. с приходом es6, работает для let и const

-----------------------------------------------
CALLBACK FUNCTION

это функция (или обратный вызов), переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия.

-----------------------------------------------
LEXICAL ENVIRONMENT

1. Окружение (формируется во время интерпретации JS) это некий объект который содержит 2 свойства: 1) объект который содержит свои локальные переменные 2) ссылку на внешнее окружение (родителя).
При объявлении функции она содержит внутри себя в скрытом поле, которое мы не можем посмотреть (называется ENVIRONMENT), ссылку на окружение где она была создана. Когда она вызывается, то создаётя новое окружение, именно для этой функции.
2. Сигнал для JS, чтобы создать новое окружение, служат фигурные скобки {}
3. сначала js ищет переменные во внутр окруж, потом пытается найти на уровне выше, пока не встретит null

-----------------------------------------------
ЗАМЫКАНИЯ

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и все они могут получить доступ к внешним переменным. В JS все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").

https://learn.javascript.ru/closure#okruzhenie-v-detalyah

!!!2)
замыкание — это способность функции иметь доступ (обращаться) к своему внешнему лексическому окружению. Иными словами: это механизм с помощью которого функция может иметь доступ к переменным, которые были объявлены в "месте рождения" этой функции. То-есть, благодаря замыканию, функция не теряет связь с переменными, которые существуют\существовали в её внешнем лексическом окружении.

-----------------------------------------------
ПЕРЕДАЧА ПО ССЫЛКЕ И ПО ЗНАЧЕНИЮ
КАК КОПИРОВАТЬ МАССИВЫ И ОБЪЕКТЫ 

В отличии от примитвов объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) на это значение. Поэтому копирование такой переменной или передача её в качестве аргумента функции приводит к копированию этой ссылки, а не самого объекта.

- Объекты 
1) создать пустой объект, и методом перебора перебрать все ключи старого объекта и положить в новый и вернуть новый объект !!! самый надёжный. глубоко можно скопировать как можем
2) Object.assign(numbers, add)); // первым аргументом пишем к которому будем присоединять. можно первый аргументом просто пустой объект (не копирует глубоко)
3) spread оператор
4) JSON.stringify JSON.parse (глубоко копирует, но к сожалению методы глубоко не копирует)

Однако это всё поверхностные копирования объектов, глубокие копии делать сдлжнее

-массивы
1) slice
2)spread оператор

-----------------------------------------------
DOM

DOM - представляет собой всё содержимое html страницы в виде объектов, кот. ты можешь менять
- getElementById , getElementsByTagName, getElementsByClassName, querySelectorAll, querySelector
- чтобы посмотреть что мы можем сделать с тем или иным элементом на странице. можем посмотреть на него в качестве объекта console.dir(box);
- style.border, style.cssText
- createElement, createTextNode 
- div.classList.add('black');
- document.body.append(div); prepend, before, remove, replaceWith
- childNodes получает коллекцию нод узлов
- createElement создаёт элемент
- чтобы вставить мы можем использовать before, after, prepend, append

-----------------------------------------------
EVENT LOOP

Задача event loop - наблюдать за стеком и за очередью задач, и если стек пуст, то из очереди докидывать в stack
JS - однопоточный язык. Тут вопрос, как в однопоточном js выполнять асинхронный код, для этого нам нужен eventLoop (концепция цикла событий)

EL переносит наши задачи в стек вызовов(callstack)
WEB API - предоставляет слушатели событий и сетТаймаут
Очеред задач (Callback queue). задачи из очереди ждут опустошения стека
Сначала микротаски (Promise) потом макротаски (timeout)

-----------------------------------------------
ФУНКЦИЯ ПЕРВОГО КЛАССА

В JS все функции первого класса. И в JS функции имеют тот же статус, что и объекты.
Это функция выступает как обычная переменная. Функция ведёт себя как полноценные объекты.
Функция принимает что-то и возвращает другую функцию.

Функции можно рассматривать как значения и работать с ними как с данными. При этом можно выделить следующие возможности функций:
- Ссылки на функции можно хранить в константах и переменных и через них обращаться к функциям.
- Функции можно передавать другим функциям в качестве параметров.
- Функции можно возвращать из других функций.
То есть, речь идёт о том, чтобы рассматривать функции как значения и обращаться с ними как с данными.

-----------------------------------------------
ФУНКЦИЯ ВЫСШЕГО ПОРЯДКА

Функция которая создаёт или модифицирует другие функции.
(Например filter, map, reduce это ф высшего порядка)

Это функции, которые характеризуются хотя бы одной из следующих особенностей:
- Функция принимает другую функцию в качестве аргумента (таких функций может быть и несколько).
- Функция возвращает другую функцию в качестве результата своей работы.

-----------------------------------------------
ЧИСТАЯ ФУНКЦИЯ

Принципы:
1) Иммутабельность
Данные, которые в неё приходят не должны изменяться. 
(например в реакте jsx возвращаемый, не может менять пропсы, т.к. ссылочный тип данных или редьюсер чистая ф)

2) она должна что-то return

3) нет сайд(побочных) эффектов (не использовал глобальные переменные, то что пришло, нет асинхронных запросов, сетевые запросы, консольлоги)
  - Побочным эффектом называют действия, которые взаимодействуют с внешним окружением

4) детерминированность(предсказуемость) или идемпотентность - это значит какие бы данные на вход не приходили, вернёт один и тот же ответ

-----------------------------------------------
КАРРИРОВАНИЕ

Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).
Каррирование не вызывает функцию. Оно просто трансформирует её. Уменьшаем арность.

-----------------------------------------------
IIFE

IIFE это JS функция, которая выполняется сразу же после того, как она была определена.
(function () {
  statements
})();
Переменные внутри функции не могут быть использованы за пределами её области видимости.
Переменная, которой присвоено IIFE, хранит в себе результат выполнения функции, но не саму функцию.

-----------------------------------------------
РЕКУРСИЯ

Функция вызывает сама себя

Итак, рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его – к ещё более простому и так далее, пока значение не станет очевидно.

- Шагом рекурсии функция вызывает саму себя, это называется. 
- База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.

Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии. (100 000)

https://learn.javascript.ru/recursion

-----------------------------------------------
AJAX

асинхронный – действие выполняется в фоне (не в основном потоке), другими словами, таким образом, что оно не мешает пользователю взаимодействовать со страницей

AJAX – это термин, который описывает как можно используя существующие технологии получать данные с сервера в фоновом режиме и использовать их для обновления страницы (без перезагрузки). Основная цель AJAX – это сделать сайты и веб-приложения более удобными, быстрыми и отзывчивыми.

Основные преимущества использования AJAX:
- снижение трафика (из-за уменьшения объёма передаваемых данных между клиентом и сервером);
- уменьшение нагрузки на сервер (не нужно генерировать всю страницу, а только ту часть, которую нужно обновить);
- увеличение быстродействия и отзывчивости (нет необходимости в полной перезагрузки страницы, достаточно обновить содержимое только отдельных блоков);
- повышение интерактивности (с помощью AJAX можно сразу отображать результаты и сделать ресурс более удобным для пользования).



Взаимодействие с сервером через асинхронные запросы осуществляется посредством XHR или метода fetch().

-----------------------------------------------
PROMISES

Промисы — это один из приемов работы с асинхронным кодом в JS. Они возвращают результат асинхронной операции. Промисы были придуманы для решения проблемы callback hell
Промис (promise) - это объект, представляющий результат успешного или неудачного завершения асинхронной операции. Асинхронная операция, упрощенно говоря, это некоторое действие, выполняется независимо от окружающего ее кода, в котором она вызывается, не блокирует выполнение вызываемого кода.

- У промиса есть три состояния: pending fulfilled rejected
- В качестве параметров конструктор промиса принимает resolve и reject
- Результат может быть обработан в методе .then, ошибка — в методе .catch. Метод .then также возвращает промис, поэтому мы можем использовать цепочку, состоящую из нескольких .then.

- Promise.all() - возвращает единый объект Promise, который объединяет набор промисов. Значения всех промисов возвращаются только если все они завершились успешно. Если хотя бы один reject, то пойдёт в catch
Promise.all([принимает набор промисов, промис1, промис2])then...
- Promise.allSettled - принимает набор промисов и выполняет их как единое целое, но возвращает объект со статусом и результатом промиса.
- Promise.race() также принимает несколько промисов, только возвращает первый завершенный промис (вне зависимости завершился от успешно или с ошибкой)
- Promise.any() принимает несколько промисов и возвращает первый успешно завершившийся промис. Если же все промисы завершились с ошибкой, то генерируется исключение типа AggregateError. С помощью свойства errors типа AggregateError можно получить в виде массива все ошибки, которые возникли в промисах.

-----------------------------------------------
ASYNC/AWAIT

Cпособ написания асинхронного кода в JS. Им оборачивают промис. Он делает код более читаемым и чистым, чем промисы и функции обратного вызова.

- «async» ставим перед функцией и заставляет ее возвращать промис
- «await» можно использовать только внутри асинхронной функции. Ожидает завершения выражения справа, чтобы вернуть его значение перед выполнением следующей строчки кода.

-----------------------------------------------
THIS

This это контекст вызова, то что окружает функцию и в каких условиях она вызывается.
This - это привязка, которая создаётся во время вызова функции, и на что она ссылается определяется тем, где и при каких условиях функция была вызвана.

- Обычная функция: this = window, но если use strict - undefined
- Контекст у методов объектов - это сам объект
- this в конструкторах и классах - это новый экземпляр объекта
- Ручная привязка this с помощью методов call, apply, bind

-----------------------------------------------
CLASSES

Классы — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование

-----------------------------------------------
NEW

Используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).

«new» делает 4 вещи:

- Создает пустой объект.
- Привязывает к нему значение this.
- Функция наследует от functionName.prototype.
- Возвращает значение this, если не указано иное.

-----------------------------------------------
...REST

const log = function(a, b, ...rest) { // допустим, у нас есть два обязательных аргумента, а дальше мы не знаем будут ли они, и сколько их будет, если вообще будут. Для этого топератор ....rest. Он всегда записывается в конце. при этом сам оператор это три точки, а название после может быть любым
	console.log(a, b, rest);
}

log('basic', 'rest', 'operator', 'usage'); 
// basic rest [ 'operator', 'usage' ] мы получим обязательные аргументы просто, а остальные в массиве. Т.е. rest собирает в массив.


-----------------------------------------------
FETCH

let promise = fetch(url, [options])
url – URL для отправки запроса.
options – дополнительные параметры: метод, заголовки и так далее.

- Без options это простой GET-запрос, скачивающий содержимое по адресу url.

1) Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер пришлёт заголовки ответа.
на этом этапе Мы можем увидеть HTTP-статус в свойствах ответа:
status: код
ok: если код 200, то true

2) Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.

Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:

response.text() – читает ответ и возвращает как обычный текст,
response.json() – декодирует ответ в формате JSON,
response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),
response.blob() – возвращает объект как Blob (бинарные данные с типом),
response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),
помимо этого, response.body – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. Мы рассмотрим и такой пример несколько позже.

-----------------------------------------------
ООП
Инкапсуляция, Наследование, Полиморфизм - cпособность функции обрабатывать данные разных типов., Абстракция.

-----------------------------------------------
HTTP

HyperText Transfer Protocol Протокол.
Задача - обмен данными между пользовательским приложением, осуществляющим доступ к веб-ресурсам (обычно это веб-браузер) и веб-сервером. 

Методы:
GET, POST, PUT, PATCH, DELETE, CONNECT

Различия GET и POST 
- get помещает параметры в uri, post - в тело
- get получение инфы, post для обновления данных
- post в закладки не добавишь, get можно, т.к. они в форме url
- get инфа отображается в url, что увеличивает уязвимость, post можно использовать несколько методов кодирования
- размер переменной в get 2000 символов, в post до 8мб
- get кешируется, post нет

Коды состояния: 100 инфо, 200 ок, 300 редирект, 400 ерор клиент, 500 ерор сервер

Заголовки и тело сообщения ещё есть.

-----------------------------------------------
HTTPS
HTTPS - расширение протокола HTTP для поддержки шифрования в целях повышения безопасности.
Используется TCP-порт 443 вместо 80(как http)

-----------------------------------------------
Long Polling

Клиент отправляет запрос, а сервер ничего не возвращает. Запрос повисает и ждёт ответа, если время ожидание закончилось, то мы с клиента отправляем снова запрос и опять ждём.
Ждём пока не произайдёт событие, на примере с чатом этим событием может быть, отправка сообщения каким-то другим пользователем. Запрос всё ещё висит, но после того, как др пользователь отправил сообщение срабатывает, какое-то событие и сервер отправляет ответ на клиент

+ простой в реализации
+ не требует протоколов
+ затрачивает мало серверных мощностей

- менее стабильный, т.к. постоянное соединение не устанавливается

-----------------------------------------------

REST API

Передача состояния представления.
REST - это набор 6 правил, как организовать написание кода серверного веб-приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать.

Сервис, который написан с учётом всех правил РЕСТ, называется РЕСТфул.

РЕСТфул предоставляет список url-адресов, с помощью кот, сервер может принимать запросы на получение, сохр, обновл и удал. данных.
Т.е. с помощью этих урлов мы предоставляем другим разрабам некий интерфейс.

Рест это обычный запрос вида клиент-сервер с использыванием http протокола, но который имеет несколько нюансов.
1) в качестве клиента не обязательно выступает браузер (моб приложение, десктопное или другой веб сайт)
2) в качестве ответа, не привычная html страница а просто набор данных в том или ином формате (чаще json или xml)

Правила:
1)pure-data. Хорошee RESTapi это абстрактный слой между клиентом и сервером. Клиент отправляет запросы с заданными параметрами, а в ответ получает данные о текущем состоянии сервера. Т.е. в ответе сервера должны быть чистые ничем не затуманеные данные
2)коды ответов. два варианта, как получить код
- статус http ответа
- добавляем код в структуру ответа, при этом статус всегда остаётся 200 независимо от того как выполнился запрос
3)методы запросов(способы передачи данных на сервер)
Основные ошибки: 
- игнорирование написание документации к апи
- отсутствие единой структуры РЕСТ ответов
- не писать тесты

-----------------------------------------------
WEB SOCKETS

Это протокол, предназначеный для обмена сообщениями между браузером и вебсервером в режиме реального времени.
Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.
Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
open – соединение установлено,
message – получены данные,
error – ошибка,
close – соединение закрыто.

-----------------------------------------------
Алгоритмы поиска: 
- Линейный поиск
- бинарный поиск
- граф и поиск в ширину (найти путь от а до б за минимальное кол-во шагов)
- Интерполирующий поиск

Алгоритмы сортировки:
- Сортировка выбором
- пузырьком (не эффективаня)
- быстрая сортировка (эффективаня)
- сортировка слиянием
- сортировка вставками
- сортировка подсчётом
- сортировка расчёской
- сортировка перемешиванием

Структуры данных: 
- Очередь (fifo)
- Стек (lifo)
- Связный список (список узлов и ссылок или указателей) (Linked List)
- Множества
- Map
- Хеш-таблица
- Двоичное дерево поиска
- Двоичная куча
- Граф
- Нагруженное (префиксное) дерево

-----------------------------------------------
Big O

Это зависимость между входными данными и количеством операций.
Big O показывает зависимость между массивом на 100 эл, которые подаются на вход функции и количеством тактов процессора, кот нужно выполнить, чтобы алгоритм обработал эти 1000 элементов.

-----------------------------------------------

Паттерны (прокси, обсервер, декоратор, фасад)

Обсервер (наблюдатель) (подписка на новостную ленту)
Похволяет одним объектам следить за изменениями других объектом.
Формирует зависимости 1 к многим.
Суть в том, что у нас есть один объект, в котором мы можем затрегерить вызов изменений и дальше все другие объекты, которые подписаны на изменения они получают обновления и делают свой функционал.

Прокси
Структурный паттерн, который вместо реальных объектов, предоставляет спец объекты заменители. Они перехватывают вызов к оригиналам и позволяет сделать что-то до или после обращения к оригинальному объекту. Т.е. это прослойка, которая помогает произвести какие-то доп манипуляции, до того как отдать дальнейший контроль.

Декоратор
Мы можем добавлять объектам новые свойства и методы
Оборачивание объекта в класс декоратора

Фасад
Его задача скрыть простую логику, за простым фасадом
















доп инфа
https://habr.com/ru/post/486820/
открыть вс код с теорией и чистым js
блокноты 2
ещё теорию вёрстки




__________________________________________________________________________________________________________________________________________________________________________________________________________________
2 && 1 && null && 0 && undefined // ответ null. Разберём почему. Дело в том что && всегда зпинается на false, и выводит значение того, кто дал этот false. И т.к. 2 и 1 это true, a null это false, он запнулся на null и вывел нам его.

null || 2 && 3 || 4 // ответ 3. Сначала мы должны понять какой логичекий оператор слеудет выполнять первее, поэтому мы гуглим приорететы операторов js. выясняем, что у && приоретет выше и мы его выполняем первым. 2 && 3 даёт нам true и в 2 и в 3, и т.к. последний 3, то тут будет 3. Далее выполняем null || 3 , и тут следует знать, что || запинается на правде(true) а дальше не идёт, поэтому ответ 3.