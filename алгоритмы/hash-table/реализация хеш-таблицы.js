// Чтобы реализовать хеш-таблицу с использованием JavaScript, мы сделаем три вещи: создадим класс хеш-таблицы, добавим хеш-функцию и реализуем метод для добавления пар ключ / значение в нашу таблицу.

class HashTable {
	constructor() {
		this.values = {}; // сколько сегментов содержит хеш-т
		this.length = 0; // длинна значений
		this.size = 10; // длинна хеш-таблицы
	}

	// создаём функцию хэширования. Она принимает предоставленный ключ и возвращает хэш, вычисленный с использованием арифметического модуля
	calculateHash(key) {
		return key.toString().length % this.size;
	}

	// метод для вставки пар ключ / значение.
	add(key, value) {
		const hash = this.calculateHash(key); // вычисляем хеш для ключа
		// если хеш не существует, то сохраняем его в нашем хранилище объектов.
		if (!this.values.hasOwnProperty(hash)) {
			this.values[hash] = {};
		}
		// eсли ключ не сохранен, мы сохраняем ключ и значение и увеличиваем размер нашей хеш-таблицы.
		if (!this.values[hash].hasOwnProperty(key)) {
			this.length++;
		}
		this.values[hash][key] = value;
	}
}

// попробуем использовать

const obj = new HashTable();

obj.add('apple', '2.3');
obj.add('orange', '1.1');
obj.add('pie', '3');

console.log(obj);

// Обратите внимание, что мы использовали Object для представления нашей хеш-таблицы. Объекты в JS фактически реализуются с помощью самих хэш-таблиц! Многие языки программирования также предоставляют поддержку хеш-таблиц либо в виде встроенных ассоциативных массивов, либо в виде стандартных библиотечных модулей.

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Реализация с помощью Bucket Chaining
// Стратегия связывания вместе с операцией изменения размера, чтобы избежать коллизий в таблице.
// Все элементы с одним и тем же хеш-ключом будут храниться в массиве по этому индексу. В структурах данных эти массивы называются корзинами. Размер хеш-таблицы установлен как н * мп * м где пп это количество ключей, которое он может удерживать, и мм — количество слотов в каждом сегменте

class HashEntry {
	constructor(key, data) {
		this.key = key; // ключ
		this.value = data; // значение
		this.next = null; // ссылка на новую запись
	}
}

const entry = new HashEntry(3, 'Educative');
console.log(String(entry.key) + ',' + entry.value);

// Теперь мы создадим HashTable класс, который представляет собой набор HashEntry объектов. Мы будем отслеживать количество слотов в таблице и текущий размер хеш-таблицы. Эти переменные пригодятся, когда нам нужно изменить размер таблицы.

class HashTable {
	constructor() {
		this.slots = 10;
		this.size = 0;
		this.bucket = [];
		for (var i = 0; i < this.slots; i++) {
			this.bucket[i] = null;
		}
	}
	get_size() {
		return this.size;
	}
	isEmpty() {
		return this.get_size() == 0;
	}
}
const ht = new HashTable();
console.log(ht.get_size());

// Последнее, что нам нужно, это хеш-функция. Для нашей реализации мы просто возьмем модульный ключ с общим размером хеш-таблицы (слотов).

getIndex(key){
    let index = key % this.slots;
    return index;
}