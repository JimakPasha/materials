Webpack конспект

----------------------------------------------------
Для чего вп?
	- Сборка экспортов и импортов (модулей)




----------------------------------------------------
npm init

иницилизируем нпм

отвечаем на вопросы, которые он нам задаёт


появляется файл джсон где будет вся инфа по проекту


там в скрипт прописать
  "scripts": {
    "build": "webpack"
  },

чтобы мы могли после команды npm run build могли вкл вп


----------------------------------------------------
npm install -D webpack webpack-cli

устанавливаем 2 пакета

-D это значит что мы устанавливаем данные зависимости только для разработки
т.е. они не пойдут в конечное приложение, они нужны нам для разработки
Это называется дев-депенденсис

1) webpack это пакет корневой
2) webpack-cli пакет, который отвечает за команды, которые доступны в консоли. (чтобы мы могли управлять вп через консоль)

----------------------------------------------------
Как взаимодействовать с вебпаком. 
1) ОЧЕНЬ РЕДКО. Можно прописывать в консоли например webpack ....
2) через webpack.config.js Создаём такой файл в корне

webpack.config.js работает у нас как инструмент для сборки и как правило мы там экспортируем объект
----------------------------------------------------
в конфиге прописываем первую настройку энтри. Она показывает с какого js файла всё тянется. Т.е. откуда вп стоит начать

module.exports = {
	entry: './src/index.js',
}

----------------------------------------------------
указываем куда нужно сложить результат работы вп

	output: {
		filename: 'bundle.js',
		path: 'dist...'
	}

- файлнэйм название файла
- а паз путь НО...
...НО лучше сделать по другому. Указать за пределами модуля, вверху встроенный модуль

const path = require('path');


а в паз указать
path: path.resolve(__dirname, 'dist')
где __dirname это системная переменная - текущая директория. 


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
теперь впервые можем запустить
npm run build

или

npx webpack

или webpack

----------------------------------------------------
если в конфиге мы укажем следующее, то сборка будет с параметром разработка и наш файл бандл соберётся не минифицированным

mode: 'development'

----------------------------------------------------
но представим, что у нас есть скрипты наши, а есть сторонние, как в нашем примере аналиткс.js
как его подключить?

	entry: {
    		main: './src/index.js',
		analytics: './src/analytics.js'
	},

	output: {
		filename: '[name].bundle.js',

где [name] это паттерн файлнэйма. Чтобы два скрипта собирались не в один бандл

----------------------------------------------------
у нас могут возникнуть проблемы с названиями в продакшне. с обновлением кэша. например мы поменяли название в файле js или внутренности, но кэш юзер не будет обновлять

с помощью паттерна файлнэйма, который позволяет вп создавать названия файла основываясь на контенте, который присутствует в этом файле

filename: '[name].[contenthash].js',

теперь у нас создаётся файл с длинным кодом, который вручную прописывать в хтмл так себе затея...

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
...поэтому познакомимся с доп функционалом - плагины

чтобы знакомиться и изучать плагины - можно заходить на нпм и прописывать нужный плагин

npm i -D html-webpack-plugin

данный плагин позволяет взаимодействовать с хтмл, создавать его и подключать скрипты с учётом названий хэшев автоматически

подключаем его в вп

все плагины подключаем после

	output: {
		filename: '[name].[contenthash].js',
		path: path.resolve(__dirname, 'dist')
	},
	plugins: [

	]

подключаем наш плагин

вверху в конфиге прописываем
const HtmlWebpackPlugin = require('html-webpack-plugin');


	plugins: [
    		new HtmlWebpackPlugin();
  	]

его можно настроить например:
		new HtmlWebpackPlugin({
			title: 'Demo webpack' (это то что будем у тега тайтл у сгенерированного индекс.хтмл)
		}),

а если нам индекс.хтмл нам нужен не пустой, а с заготовленной вёрсткой, то создаём его отдельно и указать путь. например:
new HtmlWebpackPlugin({
			template: './src/index.html'
		}),

стоит знать, что если мы указываем параметр темплэйт, то тайтл уже не будет работать, т.к. он будет браться с нашего темплэйта

По этой ссылке можно узнать как подключить сразу несколько файлов html
https://coderoad.ru/39798095/%D0%9D%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2-html-%D1%81-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC-webpack
----------------------------------------------------
Плагин для очистки папки дист

npm i -D clean-webpack-plugin

в конфиге вверху прописываем
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

а в плагины добавляем

    plugins: [
        new CleanWebpackPlugin(),
    ],


чтобы асетсы туда сюда не гонял сто раз удлял-создавал, можно поставить настройку, которая не удаляет их, если они не изменились
new CleanWebpackPlugin({ cleanStaleWebpackAssets: false }), 

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
В файле джсона в скрипте можно писать определённые команды для работы приложения

тут мы говорим, что если написать npm run dev, то приложение будет собрано в режиме дев.
Если npm run build то в режиме продакшн. Если мы их не указываем, то по умолчанию дев режим


  "scripts": {
		"dev": "webpack --mode development",
		"build": "webpack --mode production",
  },

----------------------------------------------------
Контекст.

Это строчка в конфиге которая говорит, где лежат исходники нашего приложения

теперь вп знает где исходники, и мы должны в нашем конфиге удалить везде в путях src

module.exports = {
	context: path.resolve(__dirname, 'src'),


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
лоадеры - позволяют работать вп с другмим типами данных. Такими как цсс например. Т.к. сам вебпак понимает только js

----------------------------------------------------
ЦСС СТИЛИ

В нашем src создаём папку styles и в ней файл style.css
В нашем главном index.js прописываем импорт стиля
import './styles/styles.css';
но он работать без сборки вп не будет


Нам нужно в конфиге прописать натсройки, сразу после наших плагинов

	plugins: [...],
	module: {
		rules: [
			{
				test: /\.css$/,
				use: ['style-loader', 'css-loader']
			}
		]
	}
}

в рулзах - тест мы говорим по сути вп, если файлы своим расширением соответсвуют данному паттерну (попадаются ему в качестве импортов), то ему нужно использовать следующие лодеры (use:)
use: ['style-loader', 'css-loader']
тут вп использует сначала цсс лоадер (потому что вп идёт справа налево). цсс - лоадер позволяет понимать вп импорты цсс. А стайл лоадер добавляет стили в хэдер хтмл


А теперь нам нужно установить 
npm i -D style-loader css-loader

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
watch вп

что бы не пересобирать проект всё время можно добавить watch

добавим его в наш пэкэдж джсон
в скриптс "watch": "webpack --mode development --watch"

  "scripts": {
    "dev": "webpack --mode development",
    "build": "webpack --mode production",
		"watch": "webpack --mode development --watch"
  },

и теперье если написать npm run watch 
то обновление будет постоянным


----------------------------------------------------
Как подключать json?

по умолчанию в js нельзя подключить json без использования систем импортов или аякс запросов
в вп имея джсон можно его подключить импортом к главному файлу index.js
import json from './assets/json' расширение можно не ставить т.к. тут есть понимание, что это джсон

у нас есть папка assets и там есть json.json


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
Работа с картинками

в нашу папку ассетст загрузим какую-н картинку

в нашем  главном файле index.js импортим картинку
import WebpackLogo from './assets/img-webpack.png';

но т.к. js не понимает картинок и расширений png, jpg и так далее, нужно установить ещё один тип лоадеров

Установим лоадер
npm i -D file-loader

теперь подключим и настроим

		rules: [
			{
	... тут какой-то ещё лоадер установленный например
			},
			{
				test: /\.(png|jpg|svg|gif)$/,
				use: ['file-loader']
			}



test: /\.(png|jpg|svg|gif)$/  -- тут с какими файлами мы работаем
use: ['file-loader'] -- тут какие лоадеры мы используем

всё. при сборке проекта будет подключаться наша картинка туда куда укажем

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
работа со шрифтами 

с помощью лоадера который описан выше

скачиваем нужный шрифт в папку ассетс - фонтс

создаём цсс файл где будут подключены фонт фэйсы и туда подключаем наш шрифт

далее в наш гланый цсс импортируем наш css со шрифтам и прописываем где надо нужные шрифты

в конфиге в модулях пишем

			{
				test: /\.(ttd|woff|woff2|eot)$/,
				use: ['file-loader']
			}

тест - это какие расширения
юс - каким лоудером обрабатываются

всё собираем наш проект со шрифтами


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
ЦСС БИБЛИОТЕКИ

как их подключать с помощью вп

на примере 
normalise css

устанавливаем
npm i normalize.css

только без -D . т.к. это нам нужно уже будет при сборке и должно там быть(оно летит в поле депенденсиси)

подключаем её в наш основной цсс @import "~normalize.css";
~ знак тильда означает, что нужно перейти в нод-модулес, чтобы найти нормолайз


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
Немного о нашем пэйкэдж.джсоне, а именно
  "main": "index.js",

это поле является обязательным если наш нпм пакет мы публикуем, если нет - то поставим 
"private": true,

----------------------------------------------------
Дополнительные настройки

между оутпутом и плагинами в нашем конфиге (хотя это не сильно важно), создадим новый объект

	output: {
	},
	resolve: {
    		extensions: [],
		alias:	{}
	},
	plugins: []

в extensions пишем те расширения которые наш вп будет понимть по умолчанию. т.е. если мы не хотим прописывать какое-то расширение всегда, то пишем тут расширения

например

extensions: ['.js', '.json', '.png'],

alias позволяет не прописывать пути фалы с большими вложенностями, а точнее просто их сокращать. 

Например 
		
alias: {
			'@models': path.resolve(__dirname, 'src/models'),
			'@': path.resolve(__dirname, 'src')
		}

если мы пропишем в каком-либо пути @models это тоже самое что и src/models

import Post from '@models/Post' = import Post from './src/models/Post';

----------------------------------------------------
библиотеки js

-S это значит мы будем сохр библиотеку как зависимость для нашего приложения

подключаем в основной индекс джс
import * as $ from 'jquery'; // тут написано, что импортируем всё из jquery

----------------------------------------------------
оптимизация, если в два js файла мы хотим подключить библиотеку jquery например

в наш конфиг пропишем

	optimization: {
		splitChunks: {
			chunks: 'all'
		}
	},

что произойдёт? Если вп увидит такие подключения одной библиотеки в два файла, то, он создаст отдельный файл с библиотекой(или несколько), а файлы два (например) подключит к ней.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
dev-server

чтобы не обновлять всё время страницу

устанавливаем
npm i -D webpack-dev-server

в нашем конфиге  добавим 

	devServer: {
		port: 4200 или 8080 или или  // это порт на котором будет работать сервер
	},

в нашем пэкдж.джсоне добавим в скриптс

"start": "webpack serve --mode development --open"
// опен - для того чтобы открыл в браузере

запустим сервер, откроется браузер сам
npm start

но надо знать, что при дэв-сервере наш проект тоже билдится, но он не собирается в дист, он храниться в оперативной памяти пк

----------------------------------------------------
перенос статических файлов
с помощью плагина

например у нас в src есть фавиконка, которую мы должны закидывать в дист. но в ручную это делать не ок

устанавливаем плагин
npm i -D copy-webpack-plugin

идём по документации 

в конфиг пишем
const CopyWebpackPlugin = require('copy-webpack-plugin');,

и далее в плагинах конфига создаём и настраиваем откуда куда и что будет переносится

new CopyWebpackPlugin({
			patterns: [
				{ from: path.resolve(__dirname, 'src/favicon.iсo'), to: path.resolve(__dirname, 'dist') }
			],
		})

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
ЦСС стили плагин

Мы уже подключали плагин для цсс, но там он подключается в хтмл-файл, а мы хотим отдельно

работаем по документации в самом вп сайте

npm install --save-dev mini-css-extract-plugin
(--save dev тоже самое что и -D)

в конфиге прописываем 

const MiniCssExtractPlugin = require('mini-css-extract-plugin');

Кстати, это не только плагин, но и лоадер

Поэтому в наших модулях в рулзах
use: ['style-loader', 'css-loader']
на это
use: [MiniCssExtractPlugin.loader, 'css-loader']

это позволит создавать новый файл цсс, а не стилить прям в хтмл

но для этого нужно пропистаь ещё плагин

		new MiniCssExtractPlugin({
			filename: '[name].[contenthash].css'
		})


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------

вверху нашпишем
const isDev = process.env.NODE_ENV === 'development';
//тут нод джс имеет доступ до системных переменных

тоже самое мы добавим в наш дев сервер

	devServer: {
		port: 8080,
		hot: isDev
	},

чтобы проверять перменную исДев правильно
установим 
npm i -D cross-env

после  меняем
  "scripts": {
    "dev": "cross-env NODE_ENV=development webpack --mode development",
    "build": "cross-env NODE_ENV=production webpack --mode production",
    "watch": "cross-env NODE_ENV=development webpack --mode development --watch",
    "start": "cross-env NODE_ENV=development webpack serve --mode development --open"
  },

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
Минификация хтмл

создадим переменную, которая будет значить что мы в продакшн разработке
const isProd = !isDev;

открываем наш хтмлПлагин и ставим чтобы он минифицировался, когда мы будем собирать сборку для продакшн

    new HtmlWebpackPlugin({
      template: './index.html',
			minify: {
				collapseWhitespace: isProd
			}
		}),
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
Минификация цсс

для этого установим плагины

npm install terser-webpack-plugin --save-dev

npm install --save-dev optimize-css-assets-webpack-plugin

закидываем в конфиг эти плагины в переменные вверху

const OptimizeCssAssetWebpackPlugin= require('optimize-css-assets-webpack-plugin');
const TerserWebpackPlugin = require('terser-webpack-plugin');


оптимизацию вынесем в отдельную функцию

optimization: optimization(),



и функцию расположим где-н в начале
const optimization = () => {
	const config = {
		splitChunks: {
			chunks: 'all'
		}
	}

далее пропишем условие, для того чтобы в версии прод файлы минифицировались а в дэв - нет

	if (isProd) {
		config.minimizer = [
			new OptimizeCssAssetWebpackPlugin(),
			new TerserWebpackPlugin()
		]
	}
	return config;
}

----------------------------------------------------
немного оптимизируем наши хэши.
мы сделаем так: если у нас дэв разработка, то хзэши не нужны, если прод то нужны. 
Для этого создадим функцию где поместим условие

const filename = ext => isDev ? `[name].${ext}` : `[name].[hash].${ext}`;

а затем все наши файлнэймы с хэшами заменим

filename: filename('css')
filename: filename('js')


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
работа с препроцессорами ЦСС

устанавливаем
npm i -D node-sass@4.14.1 sass-loader

в рулзы прописываем

			{
				test: /\.s[ac]ss$/,
				use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader']
			},



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
----------------------------------------------------
БЭЙБЛ

можем зайти на сайт бэйбла, перейти в сетап и выбрать вп

npm install --save-dev babel-loader @babel/core

в конфиге в рулзах пишем

      {
        test: /\.m?js$/,
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ['@babel/preset-env']
          }
        }
      }

устанавливает пресет 
npm i --save-dev @babel/preset-env

мы можем настраивать пресет, и говорить под какие браузеры это оптимизировать

добавляю в пэкджсон "browserslist": "> 0.25%, not dead",
можно после скриптов например указать

ещё нужно установить полифил
npm install --save @babel/polyfill

мы её подключаем чуть по другому. т.к. полифил идёт как отдельная библиотека

в конфиге. в модуль экспортс, в энтри - мэйн пишем следующее

main: ['@babel/polyfill', './index.js'],



----------------------------------------------------
source-map

в конфиге пишем, что если в режиме дэв, то соурсмэп нужен

devtool: isDev ? 'source-map' : false,

----------------------------------------------------
как можно проанализировать нашу сборку?

данная штука помагает анализировать какие и в каком объеме у нас установлены библиотеки

npm i webpack-bundle-analyzer -D

подключаем
const {BundleAnalyzerPlugin}= require('webpack-bundle-analyzer');

он нам нужен только в версии продакшн

поэтому все плагины помещаем в отдельную функцию, а в плагины помещаем эту функцию

в функции делаем условие, что если у нас продакшн сборка, то подключаить WebpackBundleAnalyzer 


const plugins = () => {
	const base = [
		new HtmlWebpackPlugin({
			template: './index.html',
			minify: {
				collapseWhitespace: isProd
			}
		}),
		new CleanWebpackPlugin({ cleanStaleWebpackAssets: false }),
		new CopyWebpackPlugin({
			patterns: [
				{
					from: path.resolve(__dirname, 'src/favicon.ico'), to: path.resolve(__dirname, 'dist')
				}
			],
		}),
		new MiniCssExtractPlugin({
			filename: filename('css')
		})
	]

	if (isProd) {
		base.push(new BundleAnalyzerPlugin());
	}

	return base;
}


теперь когда мы запускаем продакшн билд
и откроется на локальном хосте схема какие у меня применяются библиотеки, сколько занимают. всё наглядно видно.

либо пропишем в нашем пэкэджсоне в скриптах
"stats": "webpack --json > stats.json && webpack-bundle-analyzer stats.json"
это значит брать статистику у бандл-аналайзер

и когда напишем npm run stats выйдет тоже самое, что и при сборке продакшн - откроется отдельное окно со статистикой библиотек