WEBPACK КОНСПЕКТ

полная сборка всего тут
https://github.com/ai297/webpack-ts-eslint--empty-project
видос тут (на последних минутах смотреть, как юзать этот урок)
https://www.youtube.com/watch?v=bozzyi8Tok0
// ----------------------------------------
легенда: 

webpack - вп
// ----------------------------------------
вп общее

- основное назначение вп собирать код из модулей
- понимает только синтаксис es5
- не умеет работать с цсс, хтмл
	- но для решения этих вопросов есть плагины и лоудеры
	(для любых форматов файлов, вместе с лоудерами часто идут и плагины,
	которые имеют большие возможности по настройке)
// ----------------------------------------
Установка вп

- создаём папку
- в терминале папки npm init -y  (-y пропустить вопросы). У нас появится джсон файл.
- в джсоне оставляем только имя и скриптс, остальное можно удалить, чтобы не мешало
- устанавилваем webpack 
npm install --save-dev webpack webpack-cli
- создаём конфиг вп. Можно найти на сайте вп. или я покажу.
- создаём webpack.config.js
- в него пишем то, что на сайте	
- создаём папку src и в ней index.js
- можем затестить:
	- пишем что-н в index.js
	- пэкедж джсоне скрипт "build": "webpack" и запустить
	можно написать "build": "webpack watch" и он будет следить за нашими изменениями
	- npm run build (создаться папка дист и там наш js)
	- проверили - работает. можно дист наш удалить
- можно запросить доп файлы
	- .configeditor
	- и гитигнор

// ----------------------------------------
Устанавливаем всякое

- установить typescript глобально желательно (устанавливаетс так один раз) npm i -g typescript
- проверить что тайпскрипт установлен tsc -v
- обновить до полседней версии npm update -g typescript

- тайпскрипт npm i(сокращение от install) -D(сокращение от save-dev) typescript
- тс лоадер для вебпака npm i -D ts-loader
// ----------------------------------------
Подключаем это к вп-конфиг

module: {
		rules: [
			{ test: /\.[tj]s$/,  (регулярка говорит какие файлы нужно обрабатывать в этом лоадере)
				loader: "ts-loader",
				exclude: /node_modules/,
			},
		]
	},
	resolve: {
		extensions: [".ts", ".tsx", ".js"] (какие файлы не обязательно указывать при расширении импортов и экспортов. т.е. когда мы экспортим что-то, то не надо будет прописывать эти расшерения, он сам поймёт)
	},

- устанавливаем тайскрипт конфиг. (это делается не часто, чаще у каждого свой и копируется с проекта в проект просто)
	- tsc --init (если глобально установлен ts)
	- npx tsc --init (если ts глобально не установлен)
	- заходим в tsconfig и трогаем следующие настройки:
	- меняем "target": "ES2015", 
	- включаем "noImplicitThis": true
	- включаем (не перепутать, там их два) "rootDir": "./src",
- тс лоадер для вебпака npm i -D ts-loader
// ----------------------------------------
- если нам нужен ts, то наш индекс js и тест джс меняем на ts.
- в конфиге вебпака меняем index js на ts
- проверяем npm run build 
(как результат в папку дист появится джс файл бундл. уже минифицированный и собранный из нескольких - что является основынм назначением вп)
// ----------------------------------------
устанавливаем html плагин

- он генерирует индекс.хтмл, либо использует для этого шаблоны
- npm i -D html-webpack-plugin
- подключаем его в впконфиге:

вверху пишем так
const HtmlWebpackPlugin = require('html-webpack-plugin');
 а ниже создаём плагины после ресолва, куда будем писать наши все плагины
	plugins: [
		new HtmlWebpackPlugin(),
	]
его можно настроить например:
		new HtmlWebpackPlugin({
			title: 'Demo webpack' (это то что будем у тега тайтл у сгенерированного индекс.хтмл)
		}),
а если нам индекс.хтмл нам нужен не пустой, а с заготовленной вёрсткой, то создаём егог отдельно и указать путь. например:
templat: './src/index.html'
- для проверки сбилдим, и в нашей папке дист должен появится индекс.хтмл (причём к нему уже подключен наш бундл джс)
// ----------------------------------------
Asetы(медиа файлы)

- подключаем в  нашем конфиге в модулях, после рулзов
			{
				test: /\.(?:ico|gif|png|jpg|jpeg|svg)$/i,
				type: 'asset/resource',
			},
			{
				test: /\.(woff(2)|eot|ttf|otf)$/i,
				type: 'asset/resource',
			},
- тамже в конфиге оутпуте, посе файлнэйма напишем как мы будем сохранять наши картинки
assetModuleFileName: 'assets/[name][ext]',
- в src создадим папку assets
- для теста в неё закинем картику, добавим img в наш шаблон (индекс.хтмл), и забилдим
// ----------------------------------------
инфа про кеширование

картинки кешируются, цсс, и даже скрипты кешируются. Это хорошо. Но. Допустим мы внесли правки в код, залили всё на сервер, а мои юзеры сайта не видят изменений (без спец команды перезагрузки с очисткой кеша). и для этого нам нужно указание хэша.

- поработаем с файлами, которые могу изменяться
- для этого меняем тут найэм на хэш
assetModuleFilename: 'assets/[hash][ext]',
- но если у нас картинка идёт динамически из джс, то нам нужно прописать импорт
import img from './assets/5dc3c1937bf58.jpg';

document.body.innerHTML = `
 <img src="assets/5dc3c1937bf58.jpg" alt="build">
`;
- но для джс это норм, но ts - ругается. сделаем так:
const img = require('./assets/5dc3c1937bf58.jpg');

document.body.innerHTML = `
 <img src="${img}" alt="build">
`;

- когда сбилдим, то у картинки будет другое название (это просто хэш).
// ----------------------------------------
Плагин который может копировать файлы из одной папки в другую


- npm i -D copy-webpack-plugin
-создаем папку public
- в конфиг пишем 
const CopyPlugin = require('copy-webpack-plugin');
- ниже в плагины вписываем
		new CopyPlugin({
			patterns: [
				{ from: './public'} (откуда будем копировать, можно поставить запятую to и путь куда, есали не указывать, то в корень папки дист)
			]
		}),
- нюанс. Если папка public, будет пустая, то билд не соберётся. Он будет ругаться. Если временно нам не нужен этот плагин, то просто закоментируем вот это вот всё в плагинах
- и ещё. В хтмл нужно будет указывать путь к картинкам так, как будто он уже сбилжен, а не в папку паблик
// ----------------------------------------
Плагин Clean

- удаляет наш дист

- npm i -D clean-webpack-plugin
- добавляем в конфиг
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
-добавляем в плагины
new CleanWebpackPlugin({ cleanStaleWebpackAssets: false }), (чтобы наши асетс туда сюда не гонял сто раз, можно поставить настройку, которая не удаляет их, если они не изменились)

- работает автоматически
// ----------------------------------------
Стили

- npm i -D css-loader sass-loader sass mini-css-extract-plugin
в данном случае используем такую сборку стилей
- в конфиге пишем так
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
- и так в модулях -> рулзах
{
				test: /\.css$/i,
				use: [MiniCssExtractPlugin.loader, 'css-loader'],
			},
			{
			test: /\.s[ac]ss$/i,
			use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'],
			},
- в плагины добавляем так
		new MiniCssExtractPlugin({
			filename: '[name].[contenthash].css',
		}),
- создаём нгапример scss, а в индекс.тс пишем так:
import './styles.scss'
- как писать url в цсс.
url('./assets/*.jpg') (пишем так, вп автоматом при билде подставит)
	- но если у нас файл в папку public, то в цсс мы его не можем вставить. Точнее можем, но там чёта будет не оч (но в паблике папке пусть лежат как файлы которые указаны просто как строки и никуда не импортируются)
// ----------------------------------------
// ----------------------------------------
// ----------------------------------------
// ----------------------------------------
// ----------------------------------------
- на больших проектах часто конфиг сборка одна для версии dev, а другая (уже с минификаторами и тд) для продакшена
	- в этом случае в пэкеджсоне можно написать примерно так
	"build": "webpack --config ./webpack-dev.config.json",
	"dev-build": "webpack --config ./webpack-prod.config.json"
	т.е. используем два скрипта
// ----------------------------------------
что ещё меняем

- вп а конфиге экспортирует объект, но может экспортировать функцию. делаем это
module.exports = (env) => ({
и в конце ставим скобку });

- и тогда в пэкдд.джсоне можно прописать     "build": "webpack --env devMode=1234"
	и тогда тут module.exports = (env.devMode=123????) => ({
	вроде так. Но мы сделаем проще

- сделаем проще. так
module.exports = ({develop}) => ({ (тут синтаксис диструктуризации, мы берём поле с названием деведлоп и записываем в переменную получается)
	- а в пэкедже так
	  "scripts": {
    "build": "webpack",
		"dev": "webpack --env develop"
  },

- так же пишем так
module.exports = ({develop}) => ({
	mode: develop ? 'development' : 'prodaction',
	devtool: develop ? 'inline-source-map' : false,  (про соурсмапы почитать отдельно)

- в ts конфиге включим "inlineSourceMap": true,  
// ----------------------------------------
devServer

- устанавливаем npm i -D webpack-dev-server

- настройки в конфиге в плагинах. но он нужен только в develop mode, в продакшене не нужен поэтому в вебпак конфиге создаём переменную, куда помещаем функцию с настройками
const devServer = (isDev) => !isDev ? {} : {
	devServer: {
		open: true, (открывает браузер)
		hot: true, (горячее обновление стр)
		port: 8080, (порт, 8080 по умолчанию вроде)
		contentBase: path.join(__dirname, 'public'), (путь к статическим файлам (соединяем текущий, где леджит конфиг и паблик))
	}
};

-  в самом конце а конфиге-вп пишем (перед закрывающимися)
	...devServer(develop)
- в пэкедже.джсон меняем так где скрипт
"dev": "webpack serve --env develop"

- запускаем npm run dev
// ----------------------------------------
ESLint (находит ошибки в коде)

- устанавливаем npm i -D eslint-webpack-plugin eslint
- т.к. там есть трудности с тайскриптогм, то устанавливаем ещё вот столько всего npm i -D eslint-plugin-import eslint-config-airbnb-typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin
- закидываем в корень проекта файл .eslintrc (я его вообще вручную писал)
- ещё нужно рулзы прописать, но это ин7дивидуальная штука (я пока вообще не писал)

- добавляем в пэкджсон в скриптс
		"lint": "eslint src"
- теперь команда npm run lint будет запускать

- в конфиге
const ESLintPlugin = require('mini-css-extract-plugin');
- в конфиге после
const devServer = (isDev) => !isDev ? {} : {
	devServer: {
		open: true,
		hot: true,
		port: 8080,
		contentBase: path.join(__dirname, 'public'),
	}
};
вот это:
const esLintPlugin = (isDev) => isDev ? [] : [new ESLintPlugin({ extensions: ['ts', 'js'] })]

- в конфиге внизу в плагинсах
...esLintPlugin(develop),

- в еслинте меняем
"no-console": "error",


- теперь на билд будет ругаться, а на дев не будет

// ----------------------------------------

гайд eslint prettier airbnb webpack
https://www.youtube.com/watch?v=SydnKbGc7W8

// ----------------------------------------

если проблемы с путями

попробуй

  devServer: {
    historyApiFallback: true,
    static: './',
    port: 8080,
    hot: isDev,
  },

  output: {
    filename: filename('js'),
    path: path.resolve(__dirname, 'dist'),
    publicPath: '/',
  },

// ----------------------------------------
инфа по поводу устаревшего плгина

const OptimizeCssAssetWebpackPlugin = require('optimize-css-assets-webpack-plugin');

заменить на 

const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");