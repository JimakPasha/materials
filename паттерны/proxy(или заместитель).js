// Структурный паттерн, который вместо реальных объектов, предоставляет спец объекты заменители. Они перехватывают вызов к оригиналам и позволяет сделать что-то до или после обращения к оригинальному объекту. Т.е. это прослойка, которая помогает произвести какие-то доп манипуляции, до того как отдать дальнейший контроль.

// у нас есть класс, который открывает или закрывает дверь
class CarAccess {
  open() {
    console.log('Open door car');
  }
  close() {
    console.log('Close door car');
  }
}

// нам нужно написать класс, который будет обезапашивать открытие дверей. Что-то типо валидации

class SecuritySystem {
  constructor(door) {
    this.door = door;
  }

  open(password) {
    if (this.authenticate(password)) {
      this.door.open(); // или передаём контроль на наш оригинальный класс CarAccess
    } else {
      console.log('Access dendied!');
    }
  }

  authenticate(password) {
    return password === 'Ilon';
  }

  close() {
    this.door.close();
  }
}

// теперь создаём экземпляр доступа к машине. Экземпляр обёрнутый в нашу охранную систему

const door = new SecuritySystem(new CarAccess());

door.open('Jack'); // Access dendied!

door.open('Ilon'); // Open door car

door.close(); // Close door car

// это один из примеров. В действительности бывает разным:
// Виртуальный проксти - аналог ленивой загрузки. Загрузка тяжёлого объекта, только при необходимости
// Логирующий - хранение истории обращений
// Защищающий - то, что мы рассмотрели
// Кэширующий - т.е. частичное кэширование результатов запросов клиента и управление ими
// Применений много, важно что ПРОКСИ - это прослойка между запросами и оригинальными объектами, к которым эти запросы обращены, нужное для доп операций
